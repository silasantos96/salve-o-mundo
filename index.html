<!DOCTYPE html>
<html>
<head>
<title>Salve o Mundo! ‚Äî Vers√£o Melhorada</title>
<style>
  body { 
    background: linear-gradient(135deg, #0b1224 0%, #1a2332 50%, #0b1224 100%); 
    color: #fff; 
    font-family: 'Orbitron', sans-serif; 
    margin: 0; 
    padding: 0; 
    min-height: 100vh;
  }
  .map { 
    display: grid; 
    grid-template-columns: repeat(3, 1fr); 
    gap: 15px; 
    margin: 20px; 
    margin-right: 320px; 
  }
  .region { 
    border: 2px solid #b71c1c; 
    background: linear-gradient(145deg, #0b1224, #1a2332);
    padding: 20px; 
    text-align: center; 
    cursor: pointer; 
    min-height: 150px; 
    position: relative; 
    border-radius: 10px;
    transition: all 0.3s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  .region:hover { 
    background: linear-gradient(145deg, #112244, #223355);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.4);
  }
  .region.selected { 
    border-color: #4caf50; 
    background: linear-gradient(145deg, #1a3a1a, #2a4a2a);
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
  }
  .region.has-hero { 
    border-color: #2196f3;
    box-shadow: 0 0 15px rgba(33, 150, 243, 0.2);
  }
  .region.villain-defeated {
    border-color: #666;
    background: linear-gradient(145deg, #333, #444);
    opacity: 0.7;
  }
  .panel { 
    position: fixed; 
    right: 0; 
    top: 0; 
    width: 300px; 
    background: linear-gradient(180deg, #111 0%, #222 100%);
    height: 100%; 
    padding: 10px; 
    overflow-y: auto; 
    border-left: 3px solid #b71c1c;
    box-shadow: -5px 0 15px rgba(0,0,0,0.5);
  }
  button { 
    display: block; 
    width: 100%; 
    margin: 5px 0; 
    padding: 12px; 
    font-size: 16px; 
    background: linear-gradient(145deg, #b71c1c, #d32f2f);
    border: none; 
    color: #fff; 
    cursor: pointer; 
    border-radius: 5px;
    transition: all 0.2s ease;
    font-weight: bold;
  }
  button:hover { 
    background: linear-gradient(145deg, #d32f2f, #f44336);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
  button:disabled { 
    background: linear-gradient(145deg, #555, #666);
    cursor: not-allowed; 
    transform: none;
    box-shadow: none;
  }
  button:active {
    transform: translateY(0);
  }
  .log { 
    background-color: #000; 
    padding: 10px; 
    height: 200px; 
    overflow-y: auto; 
    font-size: 14px; 
    border-radius: 5px;
    border: 1px solid #333;
  }
  .hero-info { 
    background: linear-gradient(145deg, #222, #333);
    padding: 15px; 
    margin: 10px 0; 
    border-radius: 8px; 
    border: 1px solid #444;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }
  .hero-list { 
    max-height: 150px; 
    overflow-y: auto; 
    border-radius: 5px;
  }
  .hero-item { 
    padding: 8px; 
    margin: 3px 0; 
    background: linear-gradient(145deg, #333, #444);
    cursor: pointer; 
    border-radius: 5px; 
    transition: all 0.2s ease;
    border: 1px solid #555;
  }
  .hero-item:hover { 
    background: linear-gradient(145deg, #444, #555);
    transform: translateX(3px);
  }
  .hero-item.selected { 
    background: linear-gradient(145deg, #4caf50, #66bb6a);
    border-color: #4caf50;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
  }
  .hero-item.dead {
    background: linear-gradient(145deg, #666, #777);
    opacity: 0.5;
    text-decoration: line-through;
  }
  .villain-hp { 
    color: #ff4444; 
    font-weight: bold; 
    text-shadow: 0 0 5px rgba(255, 68, 68, 0.5);
  }
  .hero-hp { 
    color: #44ff44; 
    font-weight: bold; 
    text-shadow: 0 0 5px rgba(68, 255, 68, 0.5);
  }
  .equipment-list { 
    font-size: 12px; 
    color: #aaa; 
    margin-top: 5px;
    padding: 5px;
    background-color: rgba(0,0,0,0.3);
    border-radius: 3px;
  }
  .status-effects { 
    font-size: 11px; 
    color: #ffaa00; 
    margin-top: 5px;
    padding: 3px 6px;
    background-color: rgba(255, 170, 0, 0.2);
    border-radius: 3px;
    border: 1px solid #ffaa00;
  }
  .turn-counter { 
    background: linear-gradient(145deg, #333, #444);
    padding: 15px; 
    margin: 10px 0; 
    text-align: center; 
    font-weight: bold; 
    border-radius: 8px;
    border: 2px solid #b71c1c;
    font-size: 18px;
    text-shadow: 0 0 10px rgba(183, 28, 28, 0.5);
  }
  .damage-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #ff4444;
    font-weight: bold;
    font-size: 24px;
    pointer-events: none;
    animation: damageFloat 1s ease-out forwards;
    z-index: 1000;
  }
  .heal-indicator {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #44ff44;
    font-weight: bold;
    font-size: 20px;
    pointer-events: none;
    animation: healFloat 1s ease-out forwards;
    z-index: 1000;
  }
  @keyframes damageFloat {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -150%) scale(1.2); }
  }
  @keyframes healFloat {
    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -150%) scale(1.1); }
  }
  .victory-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(145deg, #4caf50, #66bb6a);
    color: white;
    padding: 30px;
    border-radius: 15px;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    z-index: 2000;
    animation: victoryPulse 2s ease-in-out infinite;
  }
  .defeat-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(145deg, #f44336, #e57373);
    color: white;
    padding: 30px;
    border-radius: 15px;
    font-size: 24px;
    font-weight: bold;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    z-index: 2000;
    animation: defeatShake 1s ease-in-out;
  }
  @keyframes victoryPulse {
    0%, 100% { transform: translate(-50%, -50%) scale(1); }
    50% { transform: translate(-50%, -50%) scale(1.05); }
  }
  @keyframes defeatShake {
    0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
    25% { transform: translate(-50%, -50%) rotate(-2deg); }
    75% { transform: translate(-50%, -50%) rotate(2deg); }
  }
</style>
</head>
<body>
<h1>Salve o Mundo! ‚Äî Vers√£o Melhorada</h1>
<div class="map" id="map"></div>
<div class="panel">
  <div class="turn-counter" id="turnCounter">Turno: 1</div>
  
  <h2>Selecionar Her√≥i</h2>
  <div class="hero-list" id="heroList"></div>
  
  <h2>Her√≥i Selecionado</h2>
  <div class="hero-info" id="heroInfo">Nenhum her√≥i selecionado</div>
  
  <h2>A√ß√µes</h2>
  <button id="rollDiceBtn" onclick="rollDice()">Rolar Dado</button>
  <button id="attackBtn" onclick="attack()" disabled>Atacar</button>
  <button id="specialBtn" onclick="special()" disabled>Usar Habilidade</button>
  <button id="moveBtn" onclick="moveHero()" disabled>Mover</button>
  <button id="healBtn" onclick="healHero()" disabled>Curar</button>
  <button id="pickEquipmentBtn" onclick="pickEquipment()" disabled>Pegar Equipamento</button>
  <button id="endTurnBtn" onclick="endTurn()">Fim de Turno</button>
  
  <h3>Log</h3>
  <div class="log" id="log"></div>
</div>

<script src="/salve-o-mundo/heroes_data.js"></script>
<script>
// Estado do jogo
let gameState = {
  turn: 1,
  selectedHero: null,
  selectedRegion: null,
  diceResult: null,
  actionsUsed: {
    attack: false,
    special: false,
    move: false,
    heal: false,
    equipment: false
  }
};

// Lista de fichas de equipamento
const equipmentDeck = [
  {name: 'Arco M√°gico', effect: h => { h.attackBoost = (h.attackBoost || 0) + 3; log(`${h.name} usa Arco M√°gico e ganha +3 ataque.`); }},
  {name: 'Luvas de Poder', effect: h => {h.attackBoost = (h.attackBoost || 0) + 2; log(`${h.name} recebe +2 ataque.`);}},
  {name: 'Elmo de Cura', effect: h => {h.hp = Math.min(h.hp + 3, h.maxHp); log(`${h.name} cura 3 HP.`);}},
  {name: 'Anel de Teletransporte', effect: h => {h.canTeleport = true; log(`${h.name} pode se mover para qualquer regi√£o.`);}},
  {name: 'Amuleto de Resist√™ncia', effect: h => {h.defenseBoost = (h.defenseBoost || 0) + 2; log(`${h.name} recebe +2 defesa.`);}},
  {name: 'Capa de Invisibilidade', effect: h => {h.invisible = true; log(`${h.name} ficar√° invis√≠vel no pr√≥ximo turno.`);}},
  {name: 'Bast√£o de Energia', effect: h => {h.areaAttack = true; log(`${h.name} pode atacar todos os vil√µes da regi√£o.`);}},
  {name: 'Cajado de Gelo', effect: h => {h.freezeAttack = true; log(`${h.name} pode congelar vil√µes por 1 turno.`);}},
  {name: 'Escudo de Energia', effect: h => {h.reflectDamage = true; log(`${h.name} reflete ataques de volta.`);}},
  {name: 'Po√ß√£o M√°gica', effect: h => {h.hp = h.maxHp; log(`${h.name} recupera todo HP.`);}}
];

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

// Simula√ß√£o de roster
let villains = villainsData;
let heroes = heroesData;

// Distribuir equipamentos aleat√≥rios (2 por regi√£o)
function dealEquipments() {
  const deck = shuffle([...equipmentDeck]);
  return [deck.pop(), deck.pop()].map(eq => ({...eq, hidden: true}));
}

const regions = [
  {name: 'Cidade', villain: villains[0], heroes: [], equipments: dealEquipments()},
  {name: 'Floresta', villain: villains[1], heroes: [], equipments: dealEquipments()},
  {name: 'Laborat√≥rio', villain: villains[2], heroes: [], equipments: dealEquipments()},
  {name: 'Montanhas', villain: villains[3], heroes: [], equipments: dealEquipments()},
  {name: 'Costas', villain: villains[4], heroes: [], equipments: dealEquipments()}
];

// Distribuir her√≥is aleatoriamente nas regi√µes
heroes.forEach((hero, index) => {
  const regionIndex = index % regions.length;
  regions[regionIndex].heroes.push(hero);
  hero.region = regionIndex;
});

function initMap(){
  const map = document.getElementById('map');
  map.innerHTML = '';
  regions.forEach((r, idx) => {
    const div = document.createElement('div');
    div.className = 'region';
    
    // Adicionar classes visuais baseadas no estado
    if (gameState.selectedRegion === idx) {
      div.classList.add('selected');
    }
    if (r.heroes.length > 0) {
      div.classList.add('has-hero');
    }
    if (!r.villain || r.villain.hp <= 0) {
      div.classList.add('villain-defeated');
    }
    
    let heroList = r.heroes.map(h => `${h.name} <span class="hero-hp">(${h.hp}/${h.maxHp})</span>`).join('<br>') || 'Nenhum';
    let eqCount = r.equipments.filter(e => e.hidden).length;
    let villainInfo = r.villain && r.villain.hp > 0 ? 
      `${r.villain.name} <span class="villain-hp">(${r.villain.hp}/${r.villain.maxHp})</span>` : 
      '<span style="color: #666;">Derrotado ‚úì</span>';
    
    div.innerHTML = `
      <strong style="font-size: 16px; display: block; margin-bottom: 8px;">${r.name}</strong>
      <div style="margin: 5px 0; font-size: 13px;">ü¶π ${villainInfo}</div>
      <div style="margin: 5px 0; font-size: 11px;">ü¶∏ ${heroList}</div>
      <div style="margin: 5px 0; font-size: 10px; color: #aaa;">üì¶ Equipamentos: ${eqCount}</div>
    `;
    
    div.onclick = () => { 
      gameState.selectedRegion = idx; 
      log(`Regi√£o ${r.name} selecionada.`); 
      updateUI();
    };
    map.appendChild(div);
  });
}

function initHeroList() {
  const heroListDiv = document.getElementById('heroList');
  heroListDiv.innerHTML = '';
  heroes.forEach(hero => {
    const div = document.createElement('div');
    div.className = 'hero-item';
    if (gameState.selectedHero === hero) {
      div.classList.add('selected');
    }
    if (hero.hp <= 0) {
      div.classList.add('dead');
    }
    div.innerHTML = `${hero.name} <span class="hero-hp">(${hero.hp}/${hero.maxHp})</span>`;
    div.onclick = () => {
      if (hero.hp > 0) {
        selectHero(hero);
      } else {
        log(`${hero.name} est√° morto e n√£o pode ser selecionado.`);
      }
    };
    heroListDiv.appendChild(div);
  });
}

function selectHero(hero){
  gameState.selectedHero = hero;
  updateHeroInfo();
  updateUI();
  log(`${hero.name} selecionado.`);
}

function updateHeroInfo() {
  const heroInfoDiv = document.getElementById('heroInfo');
  if (!gameState.selectedHero) {
    heroInfoDiv.innerHTML = 'Nenhum her√≥i selecionado';
    return;
  }
  
  const hero = gameState.selectedHero;
  const totalAttack = hero.attack + (hero.attackBoost || 0);
  const totalDefense = hero.defense + (hero.defenseBoost || 0);
  const currentRegion = regions[hero.region];
  
  let statusEffects = [];
  if (hero.invisible) statusEffects.push('Invis√≠vel');
  if (hero.canTeleport) statusEffects.push('Teletransporte');
  if (hero.areaAttack) statusEffects.push('Ataque em √Årea');
  if (hero.freezeAttack) statusEffects.push('Ataque Congelante');
  if (hero.reflectDamage) statusEffects.push('Reflex√£o');
  if (hero.rangedAttack) statusEffects.push('Ataque √† Dist√¢ncia');
  
  heroInfoDiv.innerHTML = `
    <strong>${hero.name}</strong><br>
    <span class="hero-hp">HP: ${hero.hp}/${hero.maxHp}</span><br>
    Ataque: ${totalAttack}<br>
    Defesa: ${totalDefense}<br>
    Regi√£o: ${currentRegion.name}<br>
    <div style="margin: 5px 0; padding: 5px; background-color: rgba(76, 175, 80, 0.2); border-radius: 3px; font-size: 11px;">
      <strong>Habilidade:</strong> ${hero.abilityDescription}
    </div>
    ${statusEffects.length > 0 ? `<div class="status-effects">Efeitos: ${statusEffects.join(', ')}</div>` : ''}
    ${hero.equipment.length > 0 ? `<div class="equipment-list">Equipamentos: ${hero.equipment.map(e => e.name).join(', ')}</div>` : ''}
  `;
}

function updateUI() {
  initMap();
  initHeroList();
  updateHeroInfo();
  updateButtons();
  document.getElementById('turnCounter').textContent = `Turno: ${gameState.turn}`;
}

function updateButtons() {
  const hasHero = gameState.selectedHero !== null;
  const hasRegion = gameState.selectedRegion !== null;
  const heroInSelectedRegion = hasHero && hasRegion && gameState.selectedHero.region === gameState.selectedRegion;
  const hasVillainInRegion = hasRegion && regions[gameState.selectedRegion].villain && regions[gameState.selectedRegion].villain.hp > 0;
  const hasEquipmentInRegion = hasRegion && regions[gameState.selectedRegion].equipments.some(e => e.hidden);
  
  document.getElementById("attackBtn").disabled = !hasHero || !heroInSelectedRegion || !hasVillainInRegion || gameState.actionsUsed.attack;
  document.getElementById("specialBtn").disabled = !hasHero || gameState.actionsUsed.special;
  document.getElementById("moveBtn").disabled = !hasHero || gameState.actionsUsed.move;
  document.getElementById("healBtn").disabled = !hasHero || gameState.selectedHero.hp >= gameState.selectedHero.maxHp || gameState.actionsUsed.heal;
  document.getElementById("pickEquipmentBtn").disabled = !hasHero || !heroInSelectedRegion || !hasEquipmentInRegion || gameState.actionsUsed.equipment;
}

// Inicializa o jogo quando a p√°gina √© carregada
window.onload = () => {
  initMap();
  initHeroList();
  updateUI();
};

function rollDice(){
  if (!gameState.selectedHero) { 
    log('Selecione um her√≥i primeiro!'); 
    return; 
  }
  gameState.diceResult = Math.floor(Math.random() * 6) + 1;
  log(`${gameState.selectedHero.name} rolou o dado: ${gameState.diceResult}`);
function attack(){
  if (!gameState.selectedHero || gameState.actionsUsed.attack) return;
  if (gameState.selectedRegion === null) {
    log("Selecione uma regi√£o primeiro.");
    return;
  }
  
  const region = regions[gameState.selectedRegion];
  const hero = gameState.selectedHero;
  
  if (hero.region !== gameState.selectedRegion && !hero.rangedAttack) {
    log(`${hero.name} n√£o est√° na regi√£o selecionada.`);
    return;
  }
  
  if (!region.villain || region.villain.hp <= 0) {
    log("N√£o h√° vil√£o para atacar nesta regi√£o.");
    return;
  }
  
  if (gameState.diceResult === null) {
    log("Por favor, role o dado primeiro!");
    return;
  }

  const villain = region.villain;
  const attackChosen = hero.attacks[gameState.diceResult - 1]; // -1 porque o dado vai de 1 a 6
  log(`${hero.name} usa ${attackChosen.name}: ${attackChosen.description}`);

  let damageDealt = 0;
  let healAmount = 0;
  let villainFrozen = false;
  let heroProtected = false;
  let villainStunned = false;
  let teleported = false;
  let allHeroesHealed = false;
  let allVillainsDamaged = false;
  let selfDamage = 0;
  let defenseBoost = 0;
  let attackBoost = 0;
  let heroInvisible = false;
  let villainAttackReduced = 0;
  let heroEscaped = false;
  let villainImmobilized = false;

  switch(attackChosen.name) {
    case 'Amplifica√ß√£o de Poder':
      // Implementar l√≥gica de amplifica√ß√£o de poder em um aliado
      log('Habilidade de Amplifica√ß√£o de Poder precisa de sele√ß√£o de alvo.');
      break;
    case 'Golpe Telecin√©tico':
    case 'Investida Furiosa':
    case 'Raio C√≥smico':
    case 'Rel√¢mpago':
    case 'Golpe Feroz':
    case 'Soco S√¥nico':
    case 'Presas Afiadas':
    case 'Ataque b√°sico':
    case 'Golpe de sombra':
    case 'Raio de Luz':
    case 'Raio laser':
    case 'Golpe de areia':
    case 'Soco devastador':
    case 'Flecha de fogo':
    case 'Esticar soco':
    case 'Corte rel√¢mpago':
    case 'Golpe Magn√©tico':
    case 'Golpe de Vinha':
    case 'P√≥ m√°gico':
    case 'Bola de Fogo':
    case 'Disparo de laser simples':
    case 'Soco de ferro':
    case 'Ataque Veloz':
    case 'Proj√©teis telecin√©ticos':
    case 'Explos√£o de Empatia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Onda de Choque Mental':
    case 'Tempestade de Gelo':
    case 'Redemoinho de Flechas':
    case 'Salto Explosivo':
    case 'Arremesso de Granada':
    case 'Choque El√©trico':
    case 'Tempestade de Fogo':
    case 'Explos√£o Estelar':
    case 'Tornado S√¥nico':
    case 'Uivo Ensurdecedor':
    case 'Rajada temporal':
    case 'Rajada s√¥nica':
    case 'Explos√£o de Luz':
    case 'Granada de pulso':
    case 'Tornado de areia':
    case 'Chuva de areia':
    case 'Furac√£o':
    case 'Tempestade el√©trica':
    case 'Pis√£o s√≠smico':
    case 'Sopro da floresta':
    case 'Chicote el√°stico':
    case 'Golpe girat√≥rio':
    case 'Onda Magn√©tica':
    case 'Tempestade Magn√©tica':
    case 'Floresc√™ncia':
    case 'Frenesi de asas':
    case 'Pulso eletromagn√©tico':
    case 'Impacto S√¥nico':
    case 'Explos√£o de Energia':
    case 'Terremoto':
    case 'Tempestade Vegetal':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Ataque Mental Preciso':
    case 'Garras Afiadas':
    case 'Raio de Fogo':
    case 'Arremesso':
    case 'Descarga El√©trica':
    case 'Investida Enfurecida':
    case 'Implos√£o Estelar':
    case 'Ataque A√©reo':
    case 'Garras Mortais':
    case 'Corte crescente':
    case 'Crescimento Acelerado':
    case 'Raio de luz':
    case 'Disparo triplo':
    case 'Golpe de martelo':
    case 'Investida Fantasma':
    case 'Deslocamento de objetos':
    case 'Golpe A√©reo Devastador':
    case 'Soco Dourado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Barreira Ps√≠quica':
    case 'Escudo M√°gico':
    case 'Camuflagem Felina':
    case 'Escudo Divino':
    case 'Teleporte T√°tico':
    case 'Barreira Teleportada':
    case 'Prote√ß√£o impenetr√°vel':
    case 'Escudo de cip√≥':
    case 'Defesa perfeita':
    case 'Escudo de Metal':
    case 'Escudo de Luz':
    case 'Campo de for√ßa':
    case 'Escudo telecin√©tico':
    case 'Aura Calmante':
    case 'Prote√ß√£o Celestial':
    case 'Campo de For√ßa Reluzente':
    case 'Escudo de energia':
      heroProtected = true;
      log(`${hero.name} se protegeu!`);
      break;
    case 'Manipula√ß√£o Mental':
    case 'Encantamento':
      villainStunned = true;
      log(`${hero.name} controlou a mente de ${villain.name}!`);
      break;
    case 'Cura M√°gica':
    case 'Elmo de Cura':
    case 'Po√ß√£o M√°gica':
    case 'Teleporte de Suporte':
    case 'Campo El√©trico':
    case 'Reparos Autom√°ticos':
      healAmount = parseInt(attackChosen.description.match(/Recupera (\d+) pontos de vida/)?.[1] || 0);
      if (isNaN(healAmount)) healAmount = parseInt(attackChosen.description.match(/Adiciona (\d+) ponto de vida/)?.[1] || 0);
      if (isNaN(healAmount)) healAmount = hero.maxHp; // Po√ß√£o M√°gica
      hero.hp = Math.min(hero.hp + healAmount, hero.maxHp);
      log(`${hero.name} recuperou ${healAmount} HP.`);
      showHealIndicator(document.getElementById('heroInfo'), healAmount);
      break;
    case 'Teleporte':
    case 'Teletransporte C√≥smico':
    case 'Teleporte em Massa':
    case 'Voo Rel√¢mpago':
      teleported = true;
      log(`${hero.name} se teletransportou!`);
      break;
    case 'Ataque Duplo':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      // A descri√ß√£o do ataque duplo do Kriegen √© diferente, precisa de tratamento especial
      if (hero.name === 'Kriegen') {
        damageDealt = 1; // Cada ataque causa 1 de dano, s√£o 2 ataques
        villain.hp = Math.max(0, villain.hp - damageDealt);
        log(`${hero.name} ataca ${villain.name} causando ${damageDealt} de dano!`);
        showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damageDealt);
        damageDealt = 1;
      }
      break;
    case 'Rugido Atordoante':
    case 'Eletricidade Est√°tica':
    case 'Campo Gravitacional':
    case 'Ataque de Paralisia':
    case 'Ilus√£o sonora':
    case 'Raio Cegante':
    case 'Choque el√©trico':
    case 'Areia movedi√ßa':
    case 'Imobiliza√ß√£o telecin√©tica':
    case 'Desespero Manipulado':
    case 'Furac√£o A√©reo':
    case 'Carga Blindada':
    case 'Tempestade temporal':
      villainStunned = true;
      log(`${villain.name} foi paralisado/atordoado!`);
      break;
    case 'Salto √Ågil':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      heroProtected = true;
      break;
    case 'Grito de Guerra':
      if (hero.name === 'Kriegen') {
        hero.hp = Math.min(hero.hp + 1, hero.maxHp);
        hero.attackBoost = (hero.attackBoost || 0) + 1; // Para o pr√≥ximo ataque
        log(`${hero.name} recupera 1 HP e ganha +1 ataque no pr√≥ximo ataque!`);
      } else if (hero.name === 'Major Duk') {
        damageDealt = 1; // Dano a todos os vil√µes
        defenseBoost = 1; // Aumenta defesa de todos os her√≥is
        allVillainsDamaged = true;
        log(`${hero.name} aumenta a defesa de todos os her√≥is em 1!`);
      }
      break;
    case 'Ataque Rel√¢mpago':
      damageDealt = parseInt(attackChosen.description.match(/Dano de (\d+) pontos de vida/)[1]);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} recebe ${selfDamage} de dano de volta!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Carga Total':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} perde ${selfDamage} HP!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Salto Poderoso':
      heroEscaped = true;
      log(`${hero.name} esquivou do ataque!`);
      break;
    case 'Barreira de Fogo':
      heroProtected = true;
      damageDealt = 1; // Dano aos inimigos que se aproximarem
      allVillainsDamaged = true;
      break;
    case 'F√∫ria Ardente':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de dano/)[1]);
      break;
    case 'Invoca√ß√£o de Lobos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Reflexos aprimorados':
      heroEscaped = true;
      log(`${hero.name} escapou do ataque!`);
      break;
    case 'Contragolpe':
      heroEscaped = true;
      damageDealt = 2;
      log(`${hero.name} contra-atacou!`);
      break;
    case 'Escudo de areia':
      heroProtected = true;
      log(`${hero.name} se protegeu com escudo de areia!`);
      break;
    case 'Nevasca':
      damageDealt = 1;
      villainAttackReduced = 2;
      allVillainsDamaged = true;
      log(`${villain.name} teve seu ataque reduzido em ${villainAttackReduced}!`);
      break;
    case 'Arremesso de objetos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      break;
    case 'Lan√ßa de madeira':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Punho El√°stico':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'V√≥rtice de areia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Dispers√£o de Luz':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Aniquila√ß√£o':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Uppercut':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Dan√ßa dos Ventos':
      damageDealt = parseInt(attackChosen.description.match(/causando dano de (\d+) pontos de vida/)[1]);
      break;
    case 'Desorienta√ß√£o':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      villainStunned = true;
      break;
    case 'Soco Dourado':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Raio Solar':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Arremesso de escombros':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'M√≠ssil guiado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Corte crescente':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Voo da borboleta':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Transforma√ß√£o em Animal':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Ataque Furtivo':
      damageDealt = parseInt(attackChosen.description.match(/causando dano de (\d+) pontos de vida/)[1]);
      break;
    case 'Ataque telecin√©tico':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Crescimento Acelerado':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Garras de raposa':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      break;
    case 'Machado de pedra':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      break;
    case 'Rasteira':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      break;
    case 'Chute girat√≥rio':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de danos/)[1]);
      break;
    case 'Socos r√°pidos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'L√¢mina de Luz':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Lan√ßamento de estilha√ßos':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Ra√≠zes Sufocantes':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Enredar':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      villainImmobilized = true;
      break;
    case 'P√≥ m√°gico':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      villainAttackReduced = 1;
      break;
    case 'Ataque de fada':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Ilus√£o':
      villainStunned = true;
      break;
    case 'Barreira Elemental':
      heroProtected = true;
      break;
    case 'Modo rajada':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de dano/)[1]);
      break;
    case 'Carga Blindada':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      villainStunned = true;
      break;
    case 'Absor√ß√£o Emocional':
      defenseBoost = 2; // Reduz 2 pontos de dano do vil√£o
      break;
    case 'Infus√£o de Coragem':
      attackBoost = 2; // Aumenta o dano dos ataques de um aliado em 2
      log('Habilidade de Infus√£o de Coragem precisa de sele√ß√£o de alvo.');
      break;
    case 'V√≥rtice de areia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Ataque de F√∫ria':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Grito de Guerra':
      if (hero.name === 'Kriegen') {
        hero.hp = Math.min(hero.hp + 1, hero.maxHp);
        hero.attackBoost = (hero.attackBoost || 0) + 1; // Para o pr√≥ximo ataque
        log(`${hero.name} recupera 1 HP e ganha +1 ataque no pr√≥ximo ataque!`);
      } else if (hero.name === 'Major Duk') {
        damageDealt = 1; // Dano a todos os vil√µes
        defenseBoost = 1; // Aumenta defesa de todos os her√≥is
        allVillainsDamaged = true;
        log(`${hero.name} aumenta a defesa de todos os her√≥is em 1!`);
      }
      break;
    case 'Paradoxo':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} perde ${selfDamage} HP!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Raio':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Tornado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Chuva √°cida':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Agarr√£o poderoso':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Sopro da floresta':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Im√£ Poderoso':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      villainImmobilized = true;
      break;
    case 'Levita√ß√£o':
      heroEscaped = true;
      break;
    case 'Prote√ß√£o Celestial':
      heroProtected = true;
      break;
    case 'Voo Rel√¢mpago':
      teleported = true;
      break;
    default:
      log('Ataque n√£o implementado: ' + attackChosen.name);
      break;
  }

  if (allVillainsDamaged) {
    regions[hero.region].villains.forEach(v => {
      if (v.hp > 0) {
        const damage = Math.max(1, damageDealt - (v.defense || 0));
        v.hp = Math.max(0, v.hp - damage);
        log(`${hero.name} ataca ${v.name} causando ${damage} de dano!`);
        showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damage);
      }
    });
  } else if (damageDealt > 0) {
    const damage = Math.max(1, damageDealt - (villain.defense || 0));
    villain.hp = Math.max(0, villain.hp - damage);
    log(`${hero.name} ataca ${villain.name} causando ${damage} de dano!`);
    showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damage);
  }

  if (villainFrozen) villain.frozen = true;
  if (villainStunned) villain.stunned = true;
  if (villainImmobilized) villain.immobilized = true;
  if (villainAttackReduced > 0) villain.attack -= villainAttackReduced;

  gameState.actionsUsed.attack = true;
  
  if (villain.hp <= 0) {
    log(`${villain.name} foi derrotado!`);
    region.villain = null;
    checkVictory();
  }
  
  updateUI();
}fDamage = 0;
  let defenseBoost = 0;
  let attackBoost = 0;
  let heroInvisible = false;
  let villainAttackReduced = 0;
  let heroEscaped = false;
  let villainImmobilized = false;

  switch(attackChosen.name) {
    case 'Amplifica√ß√£o de Poder':
      // Implementar l√≥gica de amplifica√ß√£o de poder em um aliado
      log('Habilidade de Amplifica√ß√£o de Poder precisa de sele√ß√£o de alvo.');
      break;
    case 'Golpe Telecin√©tico':
    case 'Investida Furiosa':
    case 'Raio C√≥smico':
    case 'Rel√¢mpago':
    case 'Golpe Feroz':
    case 'Soco S√¥nico':
    case 'Presas Afiadas':
    case 'Ataque b√°sico':
    case 'Golpe de sombra':
    case 'Raio de Luz':
    case 'Raio laser':
    case 'Golpe de areia':
    case 'Soco devastador':
    case 'Flecha de fogo':
    case 'Esticar soco':
    case 'Corte rel√¢mpago':
    case 'Golpe Magn√©tico':
    case 'Golpe de Vinha':
    case 'P√≥ m√°gico':
    case 'Bola de Fogo':
    case 'Disparo de laser simples':
    case 'Soco de ferro':
    case 'Ataque Veloz':
    case 'Proj√©teis telecin√©ticos':
    case 'Explos√£o de Empatia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Onda de Choque Mental':
    case 'Tempestade de Gelo':
    case 'Redemoinho de Flechas':
    case 'Salto Explosivo':
    case 'Arremesso de Granada':
    case 'Choque El√©trico':
    case 'Tempestade de Fogo':
    case 'Explos√£o Estelar':
    case 'Tornado S√¥nico':
    case 'Uivo Ensurdecedor':
    case 'Rajada temporal':
    case 'Rajada s√¥nica':
    case 'Explos√£o de Luz':
    case 'Granada de pulso':
    case 'Tornado de areia':
    case 'Chuva de areia':
    case 'Furac√£o':
    case 'Tempestade el√©trica':
    case 'Pis√£o s√≠smico':
    case 'Sopro da floresta':
    case 'Chicote el√°stico':
    case 'Golpe girat√≥rio':
    case 'Onda Magn√©tica':
    case 'Tempestade Magn√©tica':
    case 'Floresc√™ncia':
    case 'Frenesi de asas':
    case 'Pulso eletromagn√©tico':
    case 'Impacto S√¥nico':
    case 'Explos√£o de Energia':
    case 'Terremoto':
    case 'Tempestade Vegetal':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Ataque Mental Preciso':
    case 'Garras Afiadas':
    case 'Raio de Fogo':
    case 'Arremesso':
    case 'Descarga El√©trica':
    case 'Investida Enfurecida':
    case 'Implos√£o Estelar':
    case 'Ataque A√©reo':
    case 'Garras Mortais':
    case 'Corte crescente':
    case 'Crescimento Acelerado':
    case 'Raio de luz':
    case 'Disparo triplo':
    case 'Golpe de martelo':
    case 'Investida Fantasma':
    case 'Deslocamento de objetos':
    case 'Golpe A√©reo Devastador':
    case 'Soco Dourado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Barreira Ps√≠quica':
    case 'Escudo M√°gico':
    case 'Camuflagem Felina':
    case 'Escudo Divino':
    case 'Teleporte T√°tico':
    case 'Barreira Teleportada':
    case 'Prote√ß√£o impenetr√°vel':
    case 'Escudo de cip√≥':
    case 'Defesa perfeita':
    case 'Escudo de Metal':
    case 'Escudo de Luz':
    case 'Campo de for√ßa':
    case 'Escudo telecin√©tico':
    case 'Aura Calmante':
    case 'Prote√ß√£o Celestial':
    case 'Campo de For√ßa Reluzente':
    case 'Escudo de energia':
      heroProtected = true;
      log(`${hero.name} se protegeu!`);
      break;
    case 'Manipula√ß√£o Mental':
    case 'Encantamento':
      villainStunned = true;
      log(`${hero.name} controlou a mente de ${villain.name}!`);
      break;
    case 'Cura M√°gica':
    case 'Elmo de Cura':
    case 'Po√ß√£o M√°gica':
    case 'Teleporte de Suporte':
    case 'Campo El√©trico':
    case 'Reparos Autom√°ticos':
      healAmount = parseInt(attackChosen.description.match(/Recupera (\d+) pontos de vida/)?.[1] || 0);
      if (isNaN(healAmount)) healAmount = parseInt(attackChosen.description.match(/Adiciona (\d+) ponto de vida/)?.[1] || 0);
      if (isNaN(healAmount)) healAmount = hero.maxHp; // Po√ß√£o M√°gica
      hero.hp = Math.min(hero.hp + healAmount, hero.maxHp);
      log(`${hero.name} recuperou ${healAmount} HP.`);
      showHealIndicator(document.getElementById('heroInfo'), healAmount);
      break;
    case 'Teleporte':
    case 'Teletransporte C√≥smico':
    case 'Teleporte em Massa':
    case 'Voo Rel√¢mpago':
      teleported = true;
      log(`${hero.name} se teletransportou!`);
      break;
    case 'Ataque Duplo':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      // A descri√ß√£o do ataque duplo do Kriegen √© diferente, precisa de tratamento especial
      if (hero.name === 'Kriegen') {
        damageDealt = 1; // Cada ataque causa 1 de dano, s√£o 2 ataques
        villain.hp = Math.max(0, villain.hp - damageDealt);
        log(`${hero.name} ataca ${villain.name} causando ${damageDealt} de dano!`);
        showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damageDealt);
        damageDealt = 1;
      }
      break;
    case 'Rugido Atordoante':
    case 'Eletricidade Est√°tica':
    case 'Campo Gravitacional':
    case 'Ataque de Paralisia':
    case 'Ilus√£o sonora':
    case 'Raio Cegante':
    case 'Choque el√©trico':
    case 'Areia movedi√ßa':
    case 'Imobiliza√ß√£o telecin√©tica':
    case 'Desespero Manipulado':
    case 'Furac√£o A√©reo':
    case 'Carga Blindada':
    case 'Tempestade temporal':
      villainStunned = true;
      log(`${villain.name} foi paralisado/atordoado!`);
      break;
    case 'Salto √Ågil':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      heroProtected = true;
      break;
    case 'Grito de Guerra':
      if (hero.name === 'Kriegen') {
        hero.hp = Math.min(hero.hp + 1, hero.maxHp);
        hero.attackBoost = (hero.attackBoost || 0) + 1; // Para o pr√≥ximo ataque
        log(`${hero.name} recupera 1 HP e ganha +1 ataque no pr√≥ximo ataque!`);
      } else if (hero.name === 'Major Duk') {
        damageDealt = 1; // Dano a todos os vil√µes
        defenseBoost = 1; // Aumenta defesa de todos os her√≥is
        allVillainsDamaged = true;
        log(`${hero.name} aumenta a defesa de todos os her√≥is em 1!`);
      }
      break;
    case 'Ataque Rel√¢mpago':
      damageDealt = parseInt(attackChosen.description.match(/Dano de (\d+) pontos de vida/)[1]);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} recebe ${selfDamage} de dano de volta!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Carga Total':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} perde ${selfDamage} HP!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Salto Poderoso':
      heroEscaped = true;
      log(`${hero.name} esquivou do ataque!`);
      break;
    case 'Barreira de Fogo':
      heroProtected = true;
      damageDealt = 1; // Dano aos inimigos que se aproximarem
      allVillainsDamaged = true;
      break;
    case 'F√∫ria Ardente':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de dano/)[1]);
      break;
    case 'Invoca√ß√£o de Lobos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Reflexos aprimorados':
      heroEscaped = true;
      log(`${hero.name} escapou do ataque!`);
      break;
    case 'Contragolpe':
      heroEscaped = true;
      damageDealt = 2;
      log(`${hero.name} contra-atacou!`);
      break;
    case 'Escudo de areia':
      heroProtected = true;
      log(`${hero.name} se protegeu com escudo de areia!`);
      break;
    case 'Nevasca':
      damageDealt = 1;
      villainAttackReduced = 2;
      allVillainsDamaged = true;
      log(`${villain.name} teve seu ataque reduzido em ${villainAttackReduced}!`);
      break;
    case 'Arremesso de objetos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      break;
    case 'Lan√ßa de madeira':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Punho El√°stico':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'V√≥rtice de areia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Dispers√£o de Luz':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Aniquila√ß√£o':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Uppercut':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Dan√ßa dos Ventos':
      damageDealt = parseInt(attackChosen.description.match(/causando dano de (\d+) pontos de vida/)[1]);
      break;
    case 'Desorienta√ß√£o':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      villainStunned = true;
      break;
    case 'Soco Dourado':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Raio Solar':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Arremesso de escombros':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'M√≠ssil guiado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Corte crescente':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Voo da borboleta':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Transforma√ß√£o em Animal':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Ataque Furtivo':
      damageDealt = parseInt(attackChosen.description.match(/causando dano de (\d+) pontos de vida/)[1]);
      break;
    case 'Ataque telecin√©tico':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Crescimento Acelerado':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Garras de raposa':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      break;
    case 'Machado de pedra':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      break;
    case 'Rasteira':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      break;
    case 'Chute girat√≥rio':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de danos/)[1]);
      break;
    case 'Socos r√°pidos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'L√¢mina de Luz':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Lan√ßamento de estilha√ßos':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Ra√≠zes Sufocantes':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Enredar':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      villainImmobilized = true;
      break;
    case 'P√≥ m√°gico':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      villainAttackReduced = 1;
      break;
    case 'Ataque de fada':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Ilus√£o':
      villainStunned = true;
      break;
    case 'Barreira Elemental':
      heroProtected = true;
      break;
    case 'Modo rajada':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de dano/)[1]);
      break;
    case 'Carga Blindada':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      villainStunned = true;
      break;
    case 'Absor√ß√£o Emocional':
      defenseBoost = 2; // Reduz 2 pontos de dano do vil√£o
      break;
    case 'Infus√£o de Coragem':
      attackBoost = 2; // Aumenta o dano dos ataques de um aliado em 2
      log('Habilidade de Infus√£o de Coragem precisa de sele√ß√£o de alvo.');
      break;
    case 'V√≥rtice de areia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Ataque de F√∫ria':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Grito de Guerra':
      if (hero.name === 'Kriegen') {
        hero.hp = Math.min(hero.hp + 1, hero.maxHp);
        hero.attackBoost = (hero.attackBoost || 0) + 1; // Para o pr√≥ximo ataque
        log(`${hero.name} recupera 1 HP e ganha +1 ataque no pr√≥ximo ataque!`);
      } else if (hero.name === 'Major Duk') {
        damageDealt = 1; // Dano a todos os vil√µes
        defenseBoost = 1; // Aumenta defesa de todos os her√≥is
        allVillainsDamaged = true;
        log(`${hero.name} aumenta a defesa de todos os her√≥is em 1!`);
      }
      break;
    case 'Paradoxo':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} perde ${selfDamage} HP!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Raio':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Tornado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Chuva √°cida':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Agarr√£o poderoso':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Sopro da floresta':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Im√£ Poderoso':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      villainImmobilized = true;
      break;
    case 'Levita√ß√£o':
      heroEscaped = true;
      break;
    case 'Prote√ß√£o Celestial':
      heroProtected = true;
      break;
    case 'Voo Rel√¢mpago':
      teleported = true;
      break;
    default:
      log('Ataque n√£o implementado: ' + attackChosen.name);
      break;
  }

  if (allVillainsDamaged) {
    regions[hero.region].villains.forEach(v => {
      if (v.hp > 0) {
        const damage = Math.max(1, damageDealt - (v.defense || 0));
        v.hp = Math.max(0, v.hp - damage);
        log(`${hero.name} ataca ${v.name} causando ${damage} de dano!`);
        showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damage);
      }
    });
  } else if (damageDealt > 0) {
    const damage = Math.max(1, damageDealt - (villain.defense || 0));
    villain.hp = Math.max(0, villain.hp - damage);
    log(`${hero.name} ataca ${villain.name} causando ${damage} de dano!`);
    showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damage);
  }

  if (villainFrozen) villain.frozen = true;
  if (villainStunned) villain.stunned = true;
  if (villainImmobilized) villain.immobilized = true;
  if (villainAttackReduced > 0) villain.attack -= villainAttackReduced;

  gameState.actionsUsed.attack = true;
  
  if (villain.hp <= 0) {
    log(`${villain.name} foi derrotado!`);
    region.villain = null;
    checkVictory();
  }
  
  updateUI();
}mage = 0;
  let defenseBoost = 0;
  let attackBoost = 0;
  let heroInvisible = false;
  let villainAttackReduced = 0;
  let heroEscaped = false;
  let villainImmobilized = false;

  switch(attackChosen.name) {
    case 'Amplifica√ß√£o de Poder':
      // Implementar l√≥gica de amplifica√ß√£o de poder em um aliado
      log('Habilidade de Amplifica√ß√£o de Poder precisa de sele√ß√£o de alvo.');
      break;
    case 'Golpe Telecin√©tico':
    case 'Investida Furiosa':
    case 'Raio C√≥smico':
    case 'Rel√¢mpago':
    case 'Golpe Feroz':
    case 'Soco S√¥nico':
    case 'Presas Afiadas':
    case 'Ataque b√°sico':
    case 'Golpe de sombra':
    case 'Raio de Luz':
    case 'Raio laser':
    case 'Golpe de areia':
    case 'Soco devastador':
    case 'Flecha de fogo':
    case 'Esticar soco':
    case 'Corte rel√¢mpago':
    case 'Golpe Magn√©tico':
    case 'Golpe de Vinha':
    case 'P√≥ m√°gico':
    case 'Bola de Fogo':
    case 'Disparo de laser simples':
    case 'Soco de ferro':
    case 'Ataque Veloz':
    case 'Proj√©teis telecin√©ticos':
    case 'Explos√£o de Empatia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Onda de Choque Mental':
    case 'Tempestade de Gelo':
    case 'Redemoinho de Flechas':
    case 'Salto Explosivo':
    case 'Arremesso de Granada':
    case 'Choque El√©trico':
    case 'Tempestade de Fogo':
    case 'Explos√£o Estelar':
    case 'Tornado S√¥nico':
    case 'Uivo Ensurdecedor':
    case 'Rajada temporal':
    case 'Rajada s√¥nica':
    case 'Explos√£o de Luz':
    case 'Granada de pulso':
    case 'Tornado de areia':
    case 'Chuva de areia':
    case 'Furac√£o':
    case 'Tempestade el√©trica':
    case 'Pis√£o s√≠smico':
    case 'Sopro da floresta':
    case 'Chicote el√°stico':
    case 'Golpe girat√≥rio':
    case 'Onda Magn√©tica':
    case 'Tempestade Magn√©tica':
    case 'Floresc√™ncia':
    case 'Frenesi de asas':
    case 'Pulso eletromagn√©tico':
    case 'Impacto S√¥nico':
    case 'Explos√£o de Energia':
    case 'Terremoto':
    case 'Tempestade Vegetal':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Ataque Mental Preciso':
    case 'Garras Afiadas':
    case 'Raio de Fogo':
    case 'Arremesso':
    case 'Descarga El√©trica':
    case 'Investida Enfurecida':
    case 'Implos√£o Estelar':
    case 'Ataque A√©reo':
    case 'Garras Mortais':
    case 'Corte crescente':
    case 'Crescimento Acelerado':
    case 'Raio de luz':
    case 'Disparo triplo':
    case 'Golpe de martelo':
    case 'Investida Fantasma':
    case 'Deslocamento de objetos':
    case 'Golpe A√©reo Devastador':
    case 'Soco Dourado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Barreira Ps√≠quica':
    case 'Escudo M√°gico':
    case 'Camuflagem Felina':
    case 'Escudo Divino':
    case 'Teleporte T√°tico':
    case 'Barreira Teleportada':
    case 'Prote√ß√£o impenetr√°vel':
    case 'Escudo de cip√≥':
    case 'Defesa perfeita':
    case 'Escudo de Metal':
    case 'Escudo de Luz':
    case 'Campo de for√ßa':
    case 'Escudo telecin√©tico':
    case 'Aura Calmante':
    case 'Prote√ß√£o Celestial':
    case 'Campo de For√ßa Reluzente':
    case 'Escudo de energia':
      heroProtected = true;
      log(`${hero.name} se protegeu!`);
      break;
    case 'Manipula√ß√£o Mental':
    case 'Encantamento':
      villainStunned = true;
      log(`${hero.name} controlou a mente de ${villain.name}!`);
      break;
    case 'Cura M√°gica':
    case 'Elmo de Cura':
    case 'Po√ß√£o M√°gica':
    case 'Teleporte de Suporte':
    case 'Campo El√©trico':
    case 'Reparos Autom√°ticos':
      healAmount = parseInt(attackChosen.description.match(/Recupera (\d+) pontos de vida/)?.[1] || 0);
      if (isNaN(healAmount)) healAmount = parseInt(attackChosen.description.match(/Adiciona (\d+) ponto de vida/)?.[1] || 0);
      if (isNaN(healAmount)) healAmount = hero.maxHp; // Po√ß√£o M√°gica
      hero.hp = Math.min(hero.hp + healAmount, hero.maxHp);
      log(`${hero.name} recuperou ${healAmount} HP.`);
      showHealIndicator(document.getElementById('heroInfo'), healAmount);
      break;
    case 'Teleporte':
    case 'Teletransporte C√≥smico':
    case 'Teleporte em Massa':
    case 'Voo Rel√¢mpago':
      teleported = true;
      log(`${hero.name} se teletransportou!`);
      break;
    case 'Ataque Duplo':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      // A descri√ß√£o do ataque duplo do Kriegen √© diferente, precisa de tratamento especial
      if (hero.name === 'Kriegen') {
        damageDealt = 1; // Cada ataque causa 1 de dano, s√£o 2 ataques
        villain.hp = Math.max(0, villain.hp - damageDealt);
        log(`${hero.name} ataca ${villain.name} causando ${damageDealt} de dano!`);
        showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damageDealt);
        damageDealt = 1;
      }
      break;
    case 'Rugido Atordoante':
    case 'Eletricidade Est√°tica':
    case 'Campo Gravitacional':
    case 'Ataque de Paralisia':
    case 'Ilus√£o sonora':
    case 'Raio Cegante':
    case 'Choque el√©trico':
    case 'Areia movedi√ßa':
    case 'Imobiliza√ß√£o telecin√©tica':
    case 'Desespero Manipulado':
    case 'Furac√£o A√©reo':
    case 'Carga Blindada':
    case 'Tempestade temporal':
      villainStunned = true;
      log(`${villain.name} foi paralisado/atordoado!`);
      break;
    case 'Salto √Ågil':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      heroProtected = true;
      break;
    case 'Grito de Guerra':
      if (hero.name === 'Kriegen') {
        hero.hp = Math.min(hero.hp + 1, hero.maxHp);
        hero.attackBoost = (hero.attackBoost || 0) + 1; // Para o pr√≥ximo ataque
        log(`${hero.name} recupera 1 HP e ganha +1 ataque no pr√≥ximo ataque!`);
      } else if (hero.name === 'Major Duk') {
        damageDealt = 1; // Dano a todos os vil√µes
        defenseBoost = 1; // Aumenta defesa de todos os her√≥is
        allVillainsDamaged = true;
        log(`${hero.name} aumenta a defesa de todos os her√≥is em 1!`);
      }
      break;
    case 'Ataque Rel√¢mpago':
      damageDealt = parseInt(attackChosen.description.match(/Dano de (\d+) pontos de vida/)[1]);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} recebe ${selfDamage} de dano de volta!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Carga Total':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} perde ${selfDamage} HP!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Salto Poderoso':
      heroEscaped = true;
      log(`${hero.name} esquivou do ataque!`);
      break;
    case 'Barreira de Fogo':
      heroProtected = true;
      damageDealt = 1; // Dano aos inimigos que se aproximarem
      allVillainsDamaged = true;
      break;
    case 'F√∫ria Ardente':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de dano/)[1]);
      break;
    case 'Invoca√ß√£o de Lobos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Reflexos aprimorados':
      heroEscaped = true;
      log(`${hero.name} escapou do ataque!`);
      break;
    case 'Contragolpe':
      heroEscaped = true;
      damageDealt = 2;
      log(`${hero.name} contra-atacou!`);
      break;
    case 'Escudo de areia':
      heroProtected = true;
      log(`${hero.name} se protegeu com escudo de areia!`);
      break;
    case 'Nevasca':
      damageDealt = 1;
      villainAttackReduced = 2;
      allVillainsDamaged = true;
      log(`${villain.name} teve seu ataque reduzido em ${villainAttackReduced}!`);
      break;
    case 'Arremesso de objetos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      break;
    case 'Lan√ßa de madeira':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Punho El√°stico':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'V√≥rtice de areia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Dispers√£o de Luz':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Aniquila√ß√£o':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Uppercut':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Dan√ßa dos Ventos':
      damageDealt = parseInt(attackChosen.description.match(/causando dano de (\d+) pontos de vida/)[1]);
      break;
    case 'Desorienta√ß√£o':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      villainStunned = true;
      break;
    case 'Soco Dourado':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Raio Solar':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Arremesso de escombros':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'M√≠ssil guiado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Corte crescente':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Voo da borboleta':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Transforma√ß√£o em Animal':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Ataque Furtivo':
      damageDealt = parseInt(attackChosen.description.match(/causando dano de (\d+) pontos de vida/)[1]);
      break;
    case 'Ataque telecin√©tico':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Crescimento Acelerado':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Garras de raposa':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      break;
    case 'Machado de pedra':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      break;
    case 'Rasteira':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      break;
    case 'Chute girat√≥rio':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de danos/)[1]);
      break;
    case 'Socos r√°pidos':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'L√¢mina de Luz':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Lan√ßamento de estilha√ßos':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Ra√≠zes Sufocantes':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Enredar':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) ponto de dano/)?.[1] || 0);
      villainImmobilized = true;
      break;
    case 'P√≥ m√°gico':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) ponto de dano/)[1]);
      villainAttackReduced = 1;
      break;
    case 'Ataque de fada':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Ilus√£o':
      villainStunned = true;
      break;
    case 'Barreira Elemental':
      heroProtected = true;
      break;
    case 'Modo rajada':
      damageDealt = parseInt(attackChosen.description.match(/causa (\d+) pontos de dano/)[1]);
      break;
    case 'Carga Blindada':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      villainStunned = true;
      break;
    case 'Absor√ß√£o Emocional':
      defenseBoost = 2; // Reduz 2 pontos de dano do vil√£o
      break;
    case 'Infus√£o de Coragem':
      attackBoost = 2; // Aumenta o dano dos ataques de um aliado em 2
      log('Habilidade de Infus√£o de Coragem precisa de sele√ß√£o de alvo.');
      break;
    case 'V√≥rtice de areia':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Ataque de F√∫ria':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      allVillainsDamaged = true;
      break;
    case 'Grito de Guerra':
      if (hero.name === 'Kriegen') {
        hero.hp = Math.min(hero.hp + 1, hero.maxHp);
        hero.attackBoost = (hero.attackBoost || 0) + 1; // Para o pr√≥ximo ataque
        log(`${hero.name} recupera 1 HP e ganha +1 ataque no pr√≥ximo ataque!`);
      } else if (hero.name === 'Major Duk') {
        damageDealt = 1; // Dano a todos os vil√µes
        defenseBoost = 1; // Aumenta defesa de todos os her√≥is
        allVillainsDamaged = true;
        log(`${hero.name} aumenta a defesa de todos os her√≥is em 1!`);
      }
      break;
    case 'Paradoxo':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      selfDamage = 2;
      hero.hp = Math.max(0, hero.hp - selfDamage);
      log(`${hero.name} perde ${selfDamage} HP!`);
      showDamageIndicator(document.getElementById('heroInfo'), selfDamage);
      break;
    case 'Raio':
      damageDealt = parseInt(attackChosen.description.match(/causando (\d+) pontos de dano/)[1]);
      break;
    case 'Tornado':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Chuva √°cida':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Agarr√£o poderoso':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      break;
    case 'Sopro da floresta':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      break;
    case 'Im√£ Poderoso':
      damageDealt = parseInt(attackChosen.description.match(/Causa (\d+) pontos? de dano/)?.[1] || 0);
      allVillainsDamaged = true;
      villainImmobilized = true;
      break;
    case 'Levita√ß√£o':
      heroEscaped = true;
      break;
    case 'Prote√ß√£o Celestial':
      heroProtected = true;
      break;
    case 'Voo Rel√¢mpago':
      teleported = true;
      break;
    default:
      log('Ataque n√£o implementado: ' + attackChosen.name);
      break;
  }

  if (allVillainsDamaged) {
    region.heroes.forEach(h => {
      if (h.hp > 0) {
        const damage = Math.max(1, damageDealt - (villain.defense || 0));
        villain.hp = Math.max(0, villain.hp - damage);
        log(`${hero.name} ataca todos os vil√µes na regi√£o causando ${damage} de dano!`);
        showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damage);
      }
    });
  } else if (damageDealt > 0) {
    const damage = Math.max(1, damageDealt - (villain.defense || 0));
    villain.hp = Math.max(0, villain.hp - damage);
    log(`${hero.name} ataca ${villain.name} causando ${damage} de dano!`);
    showDamageIndicator(document.querySelector(`#map div:nth-child(${gameState.selectedRegion + 1})`), damage);
  }

  if (villainFrozen) villain.frozen = true;
  if (villainStunned) villain.stunned = true;
  if (villainImmobilized) villain.immobilized = true;
  if (villainAttackReduced > 0) villain.attack -= villainAttackReduced;

  gameState.actionsUsed.attack = true;
  
  if (villain.hp <= 0) {
    log(`${villain.name} foi derrotado!`);
    region.villain = null;
    checkVictory();
  }
  
  updateUI();
}

function special(){
  if (!gameState.selectedHero || gameState.actionsUsed.special) return;
  
  const hero = gameState.selectedHero;
  gameState.actionsUsed.special = true;
  
  switch(hero.ability) {
    case 'battle_fury':
      hero.hp = Math.min(hero.hp + 3, hero.maxHp);
      hero.attackBoost = (hero.attackBoost || 0) + 2;
      log(`${hero.name} usa F√∫ria de Batalha! Recupera 3 HP e ganha +2 ataque!`);
      break;
      
    case 'magic_missile':
      if (gameState.selectedRegion !== null) {
        const region = regions[gameState.selectedRegion];
        if (region.villain && region.villain.hp > 0) {
          const damage = 4; // Dano fixo m√°gico
          region.villain.hp = Math.max(0, region.villain.hp - damage);
          log(`${hero.name} lan√ßa M√≠ssil M√°gico causando ${damage} de dano m√°gico!`);
          if (region.villain.hp <= 0) {
            log(`${region.villain.name} foi derrotado!`);
            region.villain = null;
            checkVictory();
          }
        } else {
          log(`${hero.name} lan√ßa M√≠ssil M√°gico, mas n√£o h√° alvo v√°lido!`);
        }
      } else {
        log('Selecione uma regi√£o para usar M√≠ssil M√°gico!');
      }
      break;
      
    case 'precise_shot':
      hero.rangedAttack = true;
      hero.attackBoost = (hero.attackBoost || 0) + 1;
      log(`${hero.name} usa Tiro Certeiro! Pode atacar qualquer regi√£o com +1 ataque!`);
      break;
      
    case 'divine_heal':
      if (hero.region !== null) {
        const region = regions[hero.region];
        let healedCount = 0;
        region.heroes.forEach(h => {
          if (h.hp < h.maxHp) {
            h.hp = Math.min(h.hp + 3, h.maxHp);
            healedCount++;
          }
        });
        log(`${hero.name} usa Cura Divina! ${healedCount} her√≥is foram curados na regi√£o!`);
      }
      break;
      
    case 'stealth':
      hero.invisible = true;
      hero.attackBoost = (hero.attackBoost || 0) + 3; // Ataque pelas costas
      log(`${hero.name} usa Furtividade! Fica invis√≠vel e ganha +3 ataque!`);
      break;
      
    default:
      log(`${hero.name} usa sua habilidade especial!`);
  }
  
  updateUI();
}

function moveHero(){
  if (!gameState.selectedHero || gameState.actionsUsed.move) return;
  if (gameState.selectedRegion === null) {
    log('Selecione uma regi√£o de destino primeiro.');
    return;
  }
  
  const hero = gameState.selectedHero;
  const currentRegion = hero.region;
  const targetRegion = gameState.selectedRegion;
  
  if (currentRegion === targetRegion) {
    log(`${hero.name} j√° est√° nesta regi√£o.`);
    return;
  }
  
  // Remove her√≥i da regi√£o atual
  regions[currentRegion].heroes = regions[currentRegion].heroes.filter(h => h !== hero);
  
  // Adiciona her√≥i na nova regi√£o
  regions[targetRegion].heroes.push(hero);
  hero.region = targetRegion;
  
  gameState.actionsUsed.move = true;
  log(`${hero.name} se moveu para ${regions[targetRegion].name}.`);
  
  updateUI();
}

function healHero(){
  if (!gameState.selectedHero || gameState.actionsUsed.heal) return;
  
  const hero = gameState.selectedHero;
  if (hero.hp >= hero.maxHp) {
    log(`${hero.name} j√° est√° com HP m√°ximo.`);
    return;
  }
  
  const healAmount = 3;
  hero.hp = Math.min(hero.hp + healAmount, hero.maxHp);
  gameState.actionsUsed.heal = true;
  
  log(`${hero.name} se cura e recupera ${healAmount} HP.`);
  updateUI();
}

function pickEquipment(){
  if (!gameState.selectedHero || gameState.actionsUsed.equipment) return;
  if (gameState.selectedRegion === null) {
    log('Selecione uma regi√£o primeiro.');
    return;
  }
  
  const hero = gameState.selectedHero;
  const region = regions[gameState.selectedRegion];
  
  if (hero.region !== gameState.selectedRegion) {
    log(`${hero.name} n√£o est√° na regi√£o selecionada.`);
    return;
  }
  
  let eq = region.equipments.find(e => e.hidden);
  if (!eq) {
    log('Sem equipamentos ocultos nesta regi√£o.');
    return;
  }
  
  eq.hidden = false;
  hero.equipment.push(eq);
  gameState.actionsUsed.equipment = true;
  
  log(`${hero.name} pegou ${eq.name}.`);
  eq.effect(hero);
  
  updateUI();
}

function endTurn(){
  // Reset de a√ß√µes
  gameState.actionsUsed = {
    attack: false,
    special: false,
    move: false,
    heal: false,
    equipment: false
  };
  
  // Ataques dos vil√µes com comportamentos √∫nicos
  regions.forEach(region => {
    if (region.villain && region.villain.hp > 0 && !region.villain.frozen) {
      const villain = region.villain;
      const heroesInRegion = region.heroes.filter(h => h.hp > 0 && !h.invisible);
      
      // Usar habilidade especial do vil√£o se dispon√≠vel
      if (!villain.abilityUsed) {
        useVillainAbility(villain, region);
        villain.abilityUsed = true;
      }
      
      if (heroesInRegion.length > 0) {
        const targetHero = heroesInRegion[Math.floor(Math.random() * heroesInRegion.length)];
        let damage = Math.max(1, villain.attack - (targetHero.defense + (targetHero.defenseBoost || 0)));
        
        // Modificadores baseados na habilidade do vil√£o
        if (villain.ability === 'rage' && villain.hp < villain.maxHp / 2) {
          damage += 2; // F√∫ria quando ferido
          log(`${villain.name} entra em f√∫ria!`);
        }
        
        if (villain.ability === 'stealth') {
          damage += 1; // Ataque surpresa
          log(`${villain.name} ataca de surpresa!`);
        }
        
        if (targetHero.reflectDamage) {
          villain.hp = Math.max(0, villain.hp - damage);
          log(`${targetHero.name} reflete o ataque de ${villain.name}!`);
          if (villain.hp <= 0) {
            log(`${villain.name} foi derrotado pelo reflexo!`);
            region.villain = null;
            checkVictory();
          }
        } else {
          targetHero.hp = Math.max(0, targetHero.hp - damage);
          log(`${villain.name} ataca ${targetHero.name} causando ${damage} de dano!`);
          
          if (targetHero.hp <= 0) {
            log(`${targetHero.name} foi derrotado!`);
            checkDefeat();
          }
        }
      }
    }
    
    // Remove efeitos tempor√°rios
    if (region.villain) {
      region.villain.frozen = false;
    }
  });
  
  // Remove efeitos tempor√°rios dos her√≥is
  heroes.forEach(hero => {
    hero.invisible = false;
    hero.canTeleport = false;
    hero.rangedAttack = false;
  });
  
  gameState.turn++;
  updateUI();
  log(`--- Fim do turno ${gameState.turn - 1} ---`);
}

function useVillainAbility(villain, region) {
  switch(villain.ability) {
    case 'rage':
      if (villain.hp < villain.maxHp / 2) {
        villain.attack += 1;
        log(`${villain.name} entra em f√∫ria permanente! Ataque aumentado!`);
      }
      break;
      
    case 'chaos':
      const effects = ['confuse', 'weaken', 'poison'];
      const effect = effects[Math.floor(Math.random() * effects.length)];
      const heroesInRegion = region.heroes.filter(h => h.hp > 0);
      if (heroesInRegion.length > 0) {
        const target = heroesInRegion[Math.floor(Math.random() * heroesInRegion.length)];
        switch(effect) {
          case 'confuse':
            log(`${villain.name} confunde ${target.name}! Pr√≥ximo ataque ser√° reduzido!`);
            target.confused = true;
            break;
          case 'weaken':
            target.attackBoost = (target.attackBoost || 0) - 1;
            log(`${villain.name} enfraquece ${target.name}! Ataque reduzido!`);
            break;
          case 'poison':
            target.hp = Math.max(1, target.hp - 1);
            log(`${villain.name} envenena ${target.name}! Perde 1 HP!`);
            break;
        }
      }
      break;
      
    case 'armor':
      villain.defense += 1;
      log(`${villain.name} fortalece sua armadura! Defesa aumentada!`);
      break;
      
    case 'drain':
      const allHeroes = region.heroes.filter(h => h.hp > 0);
      if (allHeroes.length > 0) {
        allHeroes.forEach(hero => {
          hero.hp = Math.max(1, hero.hp - 1);
        });
        villain.hp = Math.min(villain.hp + allHeroes.length, villain.maxHp);
        log(`${villain.name} drena vida de todos os her√≥is na regi√£o!`);
      }
      break;
  }
}

function checkVictory() {
  const remainingVillains = regions.filter(r => r.villain && r.villain.hp > 0).length;
  if (remainingVillains === 0) {
    log('üéâ VIT√ìRIA! Todos os vil√µes foram derrotados! O mundo est√° salvo!');
    showVictoryMessage();
    disableAllButtons();
  }
}

function checkDefeat() {
  const aliveHeroes = heroes.filter(h => h.hp > 0).length;
  if (aliveHeroes === 0) {
    log('üíÄ DERROTA! Todos os her√≥is foram derrotados...');
    showDefeatMessage();
    disableAllButtons();
  }
}

function disableAllButtons() {
  document.querySelectorAll('button').forEach(btn => {
    if (btn.id !== 'rollDiceBtn') {
      btn.disabled = true;
    }
  });
}

function showDamageIndicator(element, damage) {
  const indicator = document.createElement('div');
  indicator.className = 'damage-indicator';
  indicator.textContent = `-${damage}`;
  element.appendChild(indicator);
  setTimeout(() => {
    if (indicator.parentNode) {
      indicator.parentNode.removeChild(indicator);
    }
  }, 1000);
}

function showHealIndicator(element, heal) {
  const indicator = document.createElement('div');
  indicator.className = 'heal-indicator';
  indicator.textContent = `+${heal}`;
  element.appendChild(indicator);
  setTimeout(() => {
    if (indicator.parentNode) {
      indicator.parentNode.removeChild(indicator);
    }
  }, 1000);
}

function showVictoryMessage() {
  const message = document.createElement('div');
  message.className = 'victory-message';
  message.innerHTML = 'üéâ VIT√ìRIA!<br>Todos os vil√µes foram derrotados!<br>O mundo est√° salvo!';
  document.body.appendChild(message);
}

function showDefeatMessage() {
  const message = document.createElement('div');
  message.className = 'defeat-message';
  message.innerHTML = 'üíÄ DERROTA!<br>Todos os her√≥is foram derrotados...<br>O mundo est√° perdido!';
  document.body.appendChild(message);
}

function log(msg){
  const logDiv = document.getElementById('log');
  logDiv.innerHTML += msg + '<br>';
  logDiv.scrollTop = logDiv.scrollHeight;
}

// Inicializa√ß√£o
updateUI();
log('Bem-vindo ao Salve o Mundo! Selecione um her√≥i e comece sua aventura!');
</script>
</body>
</html>

